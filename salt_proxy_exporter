#!/usr/bin/env python3
# node_exporter_proxy, written by Sergio Duran (July/2019)

from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
from subprocess import Popen, PIPE
from argparse import ArgumentParser
import json

node_exporter_cmd = "curl -qs http://localhost:9100/metrics"

# parse command line arguments
parser = ArgumentParser('node_exporter_proxy')
parser.add_argument('--address',
    required=True,
    type=str,
    help='Address to bind to'
)
parser.add_argument('--port',
    required=True,
    type=int,
    help='Port to bind to'
)
args = parser.parse_args()

# Receives requests, splits the query string extracting the first part 
# (the sensor name) and then tells salt to connect to the minion to get 
# its node_exporter stats
class ProxyHTTPServer(BaseHTTPRequestHandler):
    def error(self, sensor, message):
        self.send_response(500)
        self.end_headers()

        print('%s: %s'%(sensor, message.decode()))
        self.wfile.write(message)
    
    def do_GET(self):
        sensor = self.path[1:]

        cmd = Popen(
            ['salt', '--out=json', '--static', sensor, 'cmd.run', node_exporter_cmd],
            stdout=PIPE, stderr=PIPE, close_fds=True
        )
        (stdout, stderr) = cmd.communicate()

        if cmd.returncode != 0:
            self.error(sensor, stderr)
            return

        response = json.loads(stdout.decode())

        if sensor not in response or response[sensor]=='':
            self.error(sensor, b'Invalid response')
            return

        self.send_response(200)
        self.end_headers()

        self.wfile.write(bytes(response[sensor], 'utf8'))


class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """ Handle requests in a separate thread."""

httpd = ThreadedHTTPServer((args.address, args.port), ProxyHTTPServer)
httpd.serve_forever()

